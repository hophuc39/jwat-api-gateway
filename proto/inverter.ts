// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.1
// source: inverter.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import type {
  handleUnaryCall,
  UntypedServiceImplementation,
} from '@grpc/grpc-js';
import { GrpcMethod, GrpcStreamMethod } from '@nestjs/microservices';
import { wrappers } from 'protobufjs';
import { Observable } from 'rxjs';
import { Timestamp } from './google/protobuf/timestamp';

export const protobufPackage = 'inverter';

export interface Inverter {
  id: string;
  inverterCode: string;
  inverterName: string;
  slaveAddress: string;
  startAddress: string;
  numberOfPoles: number;
  updatedDate: Date | undefined;
  useFlag: boolean;
}

export interface Pagination {
  total: number;
  page: number;
  pageSize: number;
}

export interface CreateInverterRequest {
  inverterCode: string;
  inverterName: string;
  slaveAddress: string;
  startAddress: string;
  numberOfPoles: number;
  useFlag: boolean;
}

export interface CreateInverterResponse {
  item: Inverter | undefined;
}

export interface UpdateInverterRequest {
  id: string;
  inverterName?: string | undefined;
  slaveAddress?: string | undefined;
  startAddress?: string | undefined;
  numberOfPoles?: number | undefined;
  useFlag?: boolean | undefined;
}

export interface UpdateInverterResponse {
  item: Inverter | undefined;
}

export interface DeleteInverterRequest {
  id: string;
}

export interface DeleteInverterResponse {
  success: boolean;
}

export interface FindInverterByIdRequest {
  id: string;
}

export interface FindInverterByIdResponse {
  item: Inverter | undefined;
}

export interface FindAllInvertersRequest {
  page: number;
  pageSize: number;
  inverterCode?: string | undefined;
  inverterName?: string | undefined;
  useFlag?: boolean | undefined;
}

export interface FindAllInvertersResponse {
  items: Inverter[];
  pagination: Pagination | undefined;
}

export const INVERTER_PACKAGE_NAME = 'inverter';

wrappers['.google.protobuf.Timestamp'] = {
  fromObject(value: Date) {
    return {
      seconds: value.getTime() / 1000,
      nanos: (value.getTime() % 1000) * 1e6,
    };
  },
  toObject(message: { seconds: number; nanos: number }) {
    return new Date(message.seconds * 1000 + message.nanos / 1e6);
  },
} as any;

function createBaseInverter(): Inverter {
  return {
    id: '',
    inverterCode: '',
    inverterName: '',
    slaveAddress: '',
    startAddress: '',
    numberOfPoles: 0,
    updatedDate: undefined,
    useFlag: false,
  };
}

export const Inverter: MessageFns<Inverter> = {
  encode(
    message: Inverter,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.inverterCode !== '') {
      writer.uint32(18).string(message.inverterCode);
    }
    if (message.inverterName !== '') {
      writer.uint32(26).string(message.inverterName);
    }
    if (message.slaveAddress !== '') {
      writer.uint32(34).string(message.slaveAddress);
    }
    if (message.startAddress !== '') {
      writer.uint32(42).string(message.startAddress);
    }
    if (message.numberOfPoles !== 0) {
      writer.uint32(48).int32(message.numberOfPoles);
    }
    if (message.updatedDate !== undefined) {
      Timestamp.encode(
        toTimestamp(message.updatedDate),
        writer.uint32(58).fork(),
      ).join();
    }
    if (message.useFlag !== false) {
      writer.uint32(64).bool(message.useFlag);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Inverter {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInverter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inverterCode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inverterName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.slaveAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.startAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numberOfPoles = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedDate = fromTimestamp(
            Timestamp.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.useFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePagination(): Pagination {
  return { total: 0, page: 0, pageSize: 0 };
}

export const Pagination: MessageFns<Pagination> = {
  encode(
    message: Pagination,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.total !== 0) {
      writer.uint32(8).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(16).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(24).int32(message.pageSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pagination {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.total = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateInverterRequest(): CreateInverterRequest {
  return {
    inverterCode: '',
    inverterName: '',
    slaveAddress: '',
    startAddress: '',
    numberOfPoles: 0,
    useFlag: false,
  };
}

export const CreateInverterRequest: MessageFns<CreateInverterRequest> = {
  encode(
    message: CreateInverterRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.inverterCode !== '') {
      writer.uint32(10).string(message.inverterCode);
    }
    if (message.inverterName !== '') {
      writer.uint32(18).string(message.inverterName);
    }
    if (message.slaveAddress !== '') {
      writer.uint32(26).string(message.slaveAddress);
    }
    if (message.startAddress !== '') {
      writer.uint32(34).string(message.startAddress);
    }
    if (message.numberOfPoles !== 0) {
      writer.uint32(40).int32(message.numberOfPoles);
    }
    if (message.useFlag !== false) {
      writer.uint32(48).bool(message.useFlag);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateInverterRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInverterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inverterCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inverterName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slaveAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numberOfPoles = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.useFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCreateInverterResponse(): CreateInverterResponse {
  return { item: undefined };
}

export const CreateInverterResponse: MessageFns<CreateInverterResponse> = {
  encode(
    message: CreateInverterResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.item !== undefined) {
      Inverter.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CreateInverterResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateInverterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.item = Inverter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateInverterRequest(): UpdateInverterRequest {
  return { id: '' };
}

export const UpdateInverterRequest: MessageFns<UpdateInverterRequest> = {
  encode(
    message: UpdateInverterRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    if (message.inverterName !== undefined) {
      writer.uint32(18).string(message.inverterName);
    }
    if (message.slaveAddress !== undefined) {
      writer.uint32(26).string(message.slaveAddress);
    }
    if (message.startAddress !== undefined) {
      writer.uint32(34).string(message.startAddress);
    }
    if (message.numberOfPoles !== undefined) {
      writer.uint32(40).int32(message.numberOfPoles);
    }
    if (message.useFlag !== undefined) {
      writer.uint32(48).bool(message.useFlag);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateInverterRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInverterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inverterName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slaveAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.numberOfPoles = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.useFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateInverterResponse(): UpdateInverterResponse {
  return { item: undefined };
}

export const UpdateInverterResponse: MessageFns<UpdateInverterResponse> = {
  encode(
    message: UpdateInverterResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.item !== undefined) {
      Inverter.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): UpdateInverterResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateInverterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.item = Inverter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteInverterRequest(): DeleteInverterRequest {
  return { id: '' };
}

export const DeleteInverterRequest: MessageFns<DeleteInverterRequest> = {
  encode(
    message: DeleteInverterRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteInverterRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInverterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteInverterResponse(): DeleteInverterResponse {
  return { success: false };
}

export const DeleteInverterResponse: MessageFns<DeleteInverterResponse> = {
  encode(
    message: DeleteInverterResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteInverterResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteInverterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFindInverterByIdRequest(): FindInverterByIdRequest {
  return { id: '' };
}

export const FindInverterByIdRequest: MessageFns<FindInverterByIdRequest> = {
  encode(
    message: FindInverterByIdRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== '') {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FindInverterByIdRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindInverterByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFindInverterByIdResponse(): FindInverterByIdResponse {
  return { item: undefined };
}

export const FindInverterByIdResponse: MessageFns<FindInverterByIdResponse> = {
  encode(
    message: FindInverterByIdResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.item !== undefined) {
      Inverter.encode(message.item, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FindInverterByIdResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindInverterByIdResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.item = Inverter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFindAllInvertersRequest(): FindAllInvertersRequest {
  return { page: 0, pageSize: 0 };
}

export const FindAllInvertersRequest: MessageFns<FindAllInvertersRequest> = {
  encode(
    message: FindAllInvertersRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.pageSize !== 0) {
      writer.uint32(16).int32(message.pageSize);
    }
    if (message.inverterCode !== undefined) {
      writer.uint32(26).string(message.inverterCode);
    }
    if (message.inverterName !== undefined) {
      writer.uint32(34).string(message.inverterName);
    }
    if (message.useFlag !== undefined) {
      writer.uint32(40).bool(message.useFlag);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FindAllInvertersRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindAllInvertersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.inverterCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inverterName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.useFlag = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseFindAllInvertersResponse(): FindAllInvertersResponse {
  return { items: [], pagination: undefined };
}

export const FindAllInvertersResponse: MessageFns<FindAllInvertersResponse> = {
  encode(
    message: FindAllInvertersResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.items) {
      Inverter.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      Pagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): FindAllInvertersResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindAllInvertersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(Inverter.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface InverterServiceClient {
  createInverter(
    request: CreateInverterRequest,
  ): Observable<CreateInverterResponse>;

  findAllInverters(
    request: FindAllInvertersRequest,
  ): Observable<FindAllInvertersResponse>;

  findInverterById(
    request: FindInverterByIdRequest,
  ): Observable<FindInverterByIdResponse>;

  updateInverter(
    request: UpdateInverterRequest,
  ): Observable<UpdateInverterResponse>;

  deleteInverter(
    request: DeleteInverterRequest,
  ): Observable<DeleteInverterResponse>;
}

export interface InverterServiceController {
  createInverter(
    request: CreateInverterRequest,
  ): Observable<CreateInverterResponse>;

  findAllInverters(
    request: FindAllInvertersRequest,
  ): Observable<FindAllInvertersResponse>;

  findInverterById(
    request: FindInverterByIdRequest,
  ): Observable<FindInverterByIdResponse>;

  updateInverter(
    request: UpdateInverterRequest,
  ): Observable<UpdateInverterResponse>;

  deleteInverter(
    request: DeleteInverterRequest,
  ): Observable<DeleteInverterResponse>;
}

export function InverterServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      'createInverter',
      'findAllInverters',
      'findInverterById',
      'updateInverter',
      'deleteInverter',
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcMethod('InverterService', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(
        constructor.prototype,
        method,
      );
      GrpcStreamMethod('InverterService', method)(
        constructor.prototype[method],
        method,
        descriptor,
      );
    }
  };
}

export const INVERTER_SERVICE_NAME = 'InverterService';

export type InverterServiceService = typeof InverterServiceService;
export const InverterServiceService = {
  createInverter: {
    path: '/inverter.InverterService/CreateInverter',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateInverterRequest): Buffer =>
      Buffer.from(CreateInverterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateInverterRequest =>
      CreateInverterRequest.decode(value),
    responseSerialize: (value: CreateInverterResponse): Buffer =>
      Buffer.from(CreateInverterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateInverterResponse =>
      CreateInverterResponse.decode(value),
  },
  findAllInverters: {
    path: '/inverter.InverterService/FindAllInverters',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FindAllInvertersRequest): Buffer =>
      Buffer.from(FindAllInvertersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): FindAllInvertersRequest =>
      FindAllInvertersRequest.decode(value),
    responseSerialize: (value: FindAllInvertersResponse): Buffer =>
      Buffer.from(FindAllInvertersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): FindAllInvertersResponse =>
      FindAllInvertersResponse.decode(value),
  },
  findInverterById: {
    path: '/inverter.InverterService/FindInverterById',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FindInverterByIdRequest): Buffer =>
      Buffer.from(FindInverterByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): FindInverterByIdRequest =>
      FindInverterByIdRequest.decode(value),
    responseSerialize: (value: FindInverterByIdResponse): Buffer =>
      Buffer.from(FindInverterByIdResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): FindInverterByIdResponse =>
      FindInverterByIdResponse.decode(value),
  },
  updateInverter: {
    path: '/inverter.InverterService/UpdateInverter',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateInverterRequest): Buffer =>
      Buffer.from(UpdateInverterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): UpdateInverterRequest =>
      UpdateInverterRequest.decode(value),
    responseSerialize: (value: UpdateInverterResponse): Buffer =>
      Buffer.from(UpdateInverterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): UpdateInverterResponse =>
      UpdateInverterResponse.decode(value),
  },
  deleteInverter: {
    path: '/inverter.InverterService/DeleteInverter',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteInverterRequest): Buffer =>
      Buffer.from(DeleteInverterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DeleteInverterRequest =>
      DeleteInverterRequest.decode(value),
    responseSerialize: (value: DeleteInverterResponse): Buffer =>
      Buffer.from(DeleteInverterResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DeleteInverterResponse =>
      DeleteInverterResponse.decode(value),
  },
} as const;

export interface InverterServiceServer extends UntypedServiceImplementation {
  createInverter: handleUnaryCall<
    CreateInverterRequest,
    CreateInverterResponse
  >;
  findAllInverters: handleUnaryCall<
    FindAllInvertersRequest,
    FindAllInvertersResponse
  >;
  findInverterById: handleUnaryCall<
    FindInverterByIdRequest,
    FindInverterByIdResponse
  >;
  updateInverter: handleUnaryCall<
    UpdateInverterRequest,
    UpdateInverterResponse
  >;
  deleteInverter: handleUnaryCall<
    DeleteInverterRequest,
    DeleteInverterResponse
  >;
}

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}
